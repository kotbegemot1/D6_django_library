# Приложение библиотека на джанго
Сайт предназначен для хранение информации о личной библиотеки. Вы можете хранить заметки об имеющихся у вас книгах. Функционал позволяет
добавлять книги в библиотеку, и учитывать количество копий книг. Так же можно добавлять новых авторов, новые книги и новые издания. 
Новых авторов, новые книги и новые издания можно добавить как в режиме администрирования, так и в режиме обычного пользователя,
с помощью добавленных удобных форм. Так же на сайте есть функция аренды книги для друга, где вы можете вести учет тех книг которые дали 
почитать друзьям это так же делается в режими администратора, либо в пользовательском режиме: нужно перейти во вкладку "Взяли почитать".
Там можно либо добавить нового друга, либо дать в аренду книгу уже имеющемуся в базе другу.

## Клонирование 
Клонировать репозиторий к себе на компьютер можно двумя стандартными способами:
1. Перейти на вкладку https://github.com/kotbegemot1/D5_django_library, далее найти зеленую кнопку `Clone or download` нажать на нее и 
   выбрать `Download ZIP`, после этого к вам на компьютер скачается архив. Нужно поместить этот архив в папку которую вы выделили под этот
   репозиторий и извлечь содержимое архива в эту папку.
2. Создать папку для этого репозитория открыть для эой папки gitbash, либо командную строку, взависимости от операционной системы и 
   предпочтений. Инициализировать git и клонировать репозиторий в эту папку с помощью команд:
      ```
      git init
      git clone git@github.com:kotbegemot1/D5_django_library.git
      ```
## Развернуть проект на Heroku

### Критически важные настройки файла settings.py:
DEBUG. При развертывании сайта должен быть установлен в False (DEBUG = False). Тем самым, прекратится вывод  важной отладочной информации.
SECRET_KEY. Это большое случайное число, применяемое для защиты от CRSF. Важно, чтобы ключ, используемый в продакшине, не указывался в 
исходном коде, и/или не запрашивался с другого сервера. Django рекомендует размещать значение ключа либо в переменной окружения, 
или в файле с доступом только на чтение.
      ```
      # Чтение SECRET_KEY из переменной окружения
      import os
      SECRET_KEY = os.environ['SECRET_KEY']

      #ИЛИ

      #Чтение ключа из файла
      with open('/etc/secret_key.txt') as f:
      SECRET_KEY = f.read().strip()
      ```
Далее нужно изменить приложение p_library таким образом, чтобы читать SECRET_KEY и DEBUG из переменных окружения, если те определены, 
иначе использовать значения по умолчанию.

Откройте /p_library/settings.py, закомментируйте исходное значение SECRET_KEY и добавьте новые строки, как указано ниже жирным. 
В течении разработки, никаких переменных окружения определено не было, таким образом будут использоваться значения по умолчанию 
(не имеет значения какое ключ вы используете в процессе разработки, поскольку при развертывании проекта вы будете использовать другой).
      ```
      # SECURITY WARNING: keep the secret key used in production secret!
      # SECRET_KEY = 'cg#p$g+j9tax!#a3cup@1$8obt2_+&k3q+pmu)5%asj6yjpkag'
      import os
      SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'cg#p$g+j9tax!#a3cup@1$8obt2_+&k3q+pmu)5%asj6yjpkag')
      ```
Затем закомментируйте строку с настройкой DEBUG, а затем, добавьте новую, указанную ниже.
      ```
      # SECURITY WARNING: don't run with debug turned on in production!
      # DEBUG = True
      DEBUG = bool( os.environ.get('DJANGO_DEBUG', True) )
      ```
Значение DEBUG будет True по умолчанию и станет False, в том случае, если переменная окружения DJANGO_DEBUG будет проинициализирована 
пустой строкой, то есть, DJANGO_DEBUG=''.

Далее в нашем проекте нужно создать недостающие файлы для загрузки его на Heroku
Для того, чтобы выполнить ваше приложение Heroku необходимо иметь возможность установить соответствующее окружение и зависимости, 
а также понимать как его (приложение) запустить. В случае приложений Django мы предоставляем соответствующую информацию в нескольких 
текстовых файлах:

**runtime.txt**: язык программирования и его версию.
**requirements.txt**: необходимые для Python компоненты, включая Django.
**Procfile**: Список процессов, которые будут выполнены для старта веб-приложения. Для Django это обычно сервер веб-приложений Gunicorn (скрипт .wsgi).
**wsgi.py**: конфигурация WSGI для вызова нашего приложения Django в окружении Heroku.

После этого нужно инициализировать git если его нет, а если он уже инициализирован нужно добавить в него файлы и закомитить.

## Обновить приложение для Heroku 

### Procfile
Создайте файл с именем Procfile (без расширения) в корне нашего GitHub репозитории объявить типы процессов и точки входа приложения. 
Скопируйте в него следующий текст:
```
web: gunicorn locallibrary.wsgi --log-file -
```
«web:» сообщает Heroku, что это веб динамический и может быть отправлен HTTP-трафик. Процесс, который начнется в этом динамически, - это
gunicorn, который является популярным сервером веб-приложений, который рекомендует Heruko. Мы запускаем Gunicorn, используя 
конфигурационную информацию в модуле p_library.wsgi (созданный с помощью нашего скелета приложения: /p_library/wsgi.py).

###Gunicorn
Gunicorn рекомендуемый http сервер с Django на Heroku (Как указанов Procfile выше). Это чистый python http сервер для WSGI приложений  
которые могут запускать множество параллельных python процессов в пределах одного динамического (посмотрите Deploying Python applications
with Gunicorn для получения большей информации).

Также нам не понадобится Gunicorn для обслушивания нашей p_library приложения в течение разработки, мы установим это так, чтобы он стал 
частью наших требований к Heroku для настройки на удаленном сервере.

Установка Gunicorn локально в командной строке используя пакетный менеджер pip (которые мы установили когда настраивали среду 
разработки):
```
pip3 install gunicorn
```

###Настройка Базы Данных
Мы не можем использовать базу данных SQLite по умолчанию на Heroku, потому что она основана на файлах, и она будет удалена из эфемерной 
файловой системы каждый раз, когда приложение перезагружается (обычно один раз в день и каждый раз, когда изменяется приложение или 
его переменные конфигурации ).

Механизм Heroku для обработки этой ситуации заключается в использовании надстройки базы данных и настройке веб-приложения с 
использованием информации из переменной конфигурации среды, установленной надстройкой. Существует множество опций базы данных, но мы 
будем использовать hobby уровень в базе данных postgres Heroku, поскольку это бесплатно, поддерживается Django и автоматически 
добавляется в наши новые приложения Heroku при использовании бесплатного уровня динамического плана для хобби.

Информация о подключении базы данных предоставляется на web dyno, используя конфигурационную переменную с именем DATABASE_URL. 
Вместо того, чтобы жестко кодировать эту информацию в Django, Heroku рекомендует разработчикам использовать dj-database-url пакет для 
анализа DATABASE_URL переменную окружения и автоматически преобразовать ее в желаемый формат конфигурации Django. В дополнение к 
установке пакета dj-database-url нам также потребуется установить psycopg2, поскольку Django нуждается в этом, чтобы взаимодействовать 
с базами данных Postgres.

dj-database-url (Django конфигурации базы данных из переменной окружения)
Установите dj-database-url локально, чтобы он стал частью наших требований к настройке Heroku на удаленном сервере:
```
$ pip3 install dj-database-url
```

изменения для settings.py
Откройте /locallibrary/settings.py и скопируйте следующую конфигурацию в нижнюю часть файла:
```
# Heroku: Update database configuration from $DATABASE_URL.
import dj_database_url
db_from_env = dj_database_url.config(conn_max_age=500)
DATABASES['default'].update(db_from_env)
```
Заметка:
Мы все еще будем использовать SQLite во время разработки, поскольку DATABASE_URL переменная среды не будет установлена на нашем 
компьютере разработки.
Значение conn_max_age=500 делает соединение постоянным, что намного эффективнее, чем воссоздавать соединение в каждом цикле запросов. 
Однако это необязательно и при необходимости можно удалить.

### psycopg2 (Python Postgres database support)
Django нуждается в psycopg2 для работы с базами данных Postgres, и вам нужно будет добавить это в файл requirements.txt для Heroku, 
чтобы установить это на удаленном сервере (как описано в разделе требований ниже).

Django будет использовать нашу базу данных SQLite локально по умолчанию, поскольку переменная среды DATABASE_URL не задана в нашей 
локальной среде. Если вы хотите полностью перейти на Postgres и использовать нашу бесплатную базу данных Heroku для разработки и 
производства, то вы можете. Например, чтобы установить psycopg2 и его зависимости локально в системе на базе Linux, вы должны 
использовать следующие команды bash/terminal:
```
sudo apt-get install python-pip python-dev libpq-dev postgresql postgresql-contrib
pip3 install psycopg2
```

Инструкции по установке для других платформ можно найти на веб-сайте psycopg2.

Однако вам не нужно это делать - вам не нужно, чтобы PostGreSQL был активным на локальном компьютере, если вы передаете его в Heroku в
качестве требования в файле requirements.txt (см. Ниже).


Во время разработки мы использовали Django и веб-сервер разработки Django для обслуживания наших статических файлов (CSS, JavaScript и 
т. Д.). В производственной среде вместо этого мы обычно обслуживаем статические файлы из сети доставки контента (CDN) или веб-сервера.

Чтобы упростить размещение статических файлов отдельно от веб-приложения Django, Django предоставляет средство сбора данных для сбора 
этих файлов для развертывания (имеется переменная параметров, определяющая, где файлы должны собираться при запуске collectstatic). 
Шаблоны Django относятся к месту размещения статических файлов относительно переменной параметров (STATIC_URL), так что это можно 
изменить, если статические файлы перемещаются на другой хост / сервер.

Соответствующими параметрами настройки являются:

      STATIC_URL: это базовое расположение URL, из которого будут загружены статические файлы, например, на CDN. Это используется для 
                  переменной статического шаблона, доступ к которой осуществляется в нашем базовом шаблоне. Создание нашей домашней 
                  страницы).
      STATIC_ROOT: Это абсолютный путь к каталогу, в котором инструмент «collectstatic» Django будет собирать любые статические файлы, 
                   упомянутые в наших шаблонах. После их сбора они затем могут быть загружены в группу, где бы файлы не размещались.
      STATICFILES_DIRS: В этом списке перечислены дополнительные каталоги, в которых инструмент коллективного поиска Django должен 
                        искать статические файлы.

settings.py
Откройте /p_library/settings.py и скопируйте следующую конфигурацию в нижнюю часть файла. BASE_DIR уже должен быть определен в вашем 
файле (STATIC_URL, возможно, уже был определен в файле, когда он был создан. В то время как это не причинит вреда, вы также можете 
удалить дублируемую предыдущую ссылку).
```
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.10/howto/static-files/

# The absolute path to the directory where collectstatic will collect static files for deployment.
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# The URL to use when referring to static files (where they will be served from)
STATIC_URL = '/static/'
```

Фактически мы будем делать файл, используя библиотеку WhiteNoise, которую мы устанавливаем и настраиваем в следующем разделе.

Для получения дополнительной информации см. Django и Static Assets (документы Heroku).

WhiteNoise
Существует множество способов обслуживания статических файлов на производстве (мы видели соответствующие настройки Django в предыдущих 
разделах). Heroku рекомендует использовать проект WhiteNoise для обслуживания статических активов непосредственно из Gunicorn в 
производстве.

Заметка: Heroku автоматически вызывает collectstatic и готовит ваши статические файлы для использования WhiteNoise после того, как он 
загрузит ваше приложение. Посмотрите WhiteNoise документацию для объяснения того, как она работает, и почему реализация является 
относительно эффективным методом для обслуживания этих файлов.

### Шаги по настройке WhiteNoise для использования в проекте:

### WhiteNoise
Установите WhiteNoise локально, используя следующую команду:
```
$ pip3 install whitenoise
```

### settings.py
Чтобы установить WhiteNoise в приложение Django, откройте /locallibrary/settings.py, найдите параметр MIDDLEWARE и добавьте 
WhiteNoiseMiddleware в верхней части списка, чуть ниже SecurityMiddleware:

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

При желании вы можете уменьшить размер статических файлов при их обслуживании (это более эффективно). Просто добавьте следующее в 
конец /p_library/settings.py:
```
# Simplified static file serving.
# https://warehouse.python.org/project/whitenoise/
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
```

###Requirements
Требования Python вашего веб-приложения должны храниться в файле require.txt в корневом каталоге вашего репозитория. После этого Heroku 
автоматически установит их при восстановлении вашей среды. Вы можете создать этот файл с помощью pip в командной строке (запустите в 
корне repo):
```
pip3 freeze > requirements.txt
```

После установки всех разных зависимостей выше, файл requirements.txt должен иметь по меньшей мере эти перечисленные элементы (хотя 
номера версий могут отличаться). Удалите любые другие зависимости, не перечисленные ниже, если вы явно не добавили их для этого 
приложения.

dj-database-url==0.4.1
Django==1.10.2
gunicorn==19.6.0
psycopg2==2.6.2
whitenoise==3.2.2

Убедитесь, что строка  psycopg2, подобная приведенной выше, присутствует! Даже если вы не установили это локально, вы должны добавить 
это в requirements.txt.

Среда выполнения
Файл runtime.txt, если определён, говорит Heroku, какой язык программирования использовать. Создайте файл в корне репо и добавьте 
следующий текст:

python-3.5.2
Заметка: Heroku поддерживает только небольшое количество Python runtimes. (на момент написания статьи, в том числе и выше). Heroku 
будет использовать поддерживаемую среду выполнения независимо от значения, указанного в этом файле.

Сохраните изменения в Github и перепроверьте
Далее мы сохраним все наши изменения в Github. В терминале (whist внутри нашего репозитория) введите следующие команды:
```
git add -A
git commit -m "Added files and changes required for deployment to heroku"
git push origin master
```
Прежде чем продолжить, дайте возможность проверить сайт снова локально и убедиться, что это не повлияло ни на одно из наших изменений 
выше. Запустите веб-сервер разработки как обычно, а затем проверьте, работает ли сайт, как вы ожидаете в своем браузере.
```
python3 manage.py runserver
```

Теперь мы должны быть готовы начать развертывание LocalLibrary на Heroku.

Получить аккаунт в heroku
Чтобы начать использовать Heroku, вам сначала нужно создать учетную запись:

Перейдите www.heroku.com и нажмите SIGN UP FOR FREE кнопку.
Введите ваши данные, а затем нажмите  CREATE FREE ACCOUNT. Вам будет предложено проверить свою учетную запись по адресу электронной 
почты для регистрации.
Нажмите ссылку активации учетной записи в электронной почте для регистрации. Вы вернетесь в свою учетную запись в веб-браузере.
Введите свой пароль и нажмите  SET PASSWORD AND LOGIN.
Затем вы войдете в систему и попадете в приборную панель Heroku: https://dashboard.heroku.com/apps.
Установка клиента
Загрузите и установите клиент Heroku, следуя инструкциям Heroku здесь.

После установки клиента вам будут дотупны команды. Например, чтобы получить справку о клиенте:
```
heroku help
```
Создание и загрузка веб-сайта
Чтобы создать приложение, мы запускаем команду «create» в корневом каталоге нашего репозитория. Это создает git remote («указатель на 
удаленный репозиторий»), названный heroku в нашей локальной среде git.
```
heroku create
```
Заметка: Вы можете назвать удаленный, если хотите, указав значение после «create». Если вы этого не сделаете, вы получите случайное имя. Имя используется в URL-адресе по умолчанию.

Затем мы можем подтолкнуть наше приложение в репозиторий heroku как показано ниже. Это позволит загрузить приложение, упаковать его в 
dyno, запустить collectstatic, и запустить сам сайт.
```
git push heroku master
```
Если нам повезет, приложение «заработает» на сайте, но оно не будет работать должным образом, потому что мы не настроили таблицы базы 
данных для использования нашим приложением. Для этого нам нужно использовать команду  heroku run и запустить "one off dyno" для 
выполнения операции переноса. Введите в терминал следующую команду:
```
heroku run python manage.py migrate
```
Мы также должны будем иметь возможность добавлять книги и авторов, поэтому давайте также создадим суперпользователя, снова используя 
одноразовый динамический режим:
```
heroku run python manage.py createsuperuser
```
Как только это будет завершено, мы можем посмотреть сайт. Он должен работать, хотя в нем еще нет книг. Чтобы открыть браузер на новом 
веб-сайте, используйте команду:
```
heroku open
```

Материал по развертыванию проекта на Heroku взят с https://developer.mozilla.org/ru/docs/Learn/Server-side/Django/%D0%A0%D0%B0%D0%B7%D0%B2%D0%BE%D1%80%D0%B0%D1%87%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5
